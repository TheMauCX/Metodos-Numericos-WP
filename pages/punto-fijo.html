<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Método de Punto Fijo - Métodos Numéricos</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body>
    <a href="../index.html" class="back-button">← Volver al Inicio</a>
    
    <div class="container">
        <div class="page-container">
            <h1 class="page-title">Método de Punto Fijo</h1>
            <p class="subtitle">Encuentra puntos fijos de funciones iterativas</p>

            <div class="form-section">
                <h2 class="section-title">Parámetros de Entrada</h2>
                
                <div class="form-group">
                    <label for="functionF">Función f(x):</label>
                    <input type="text" id="functionF" value="x - Math.exp(-x)" placeholder="Ejemplo: x - Math.exp(-x)">
                    <div class="input-help">Use notación JavaScript: x**2, Math.sin(x), Math.cos(x), Math.exp(x), etc.</div>
                </div>

                <div class="form-group">
                    <label for="despejeTipo">Tipo de despeje:</label>
                    <select id="despejeTipo" onchange="actualizarDespeje()">
                        <option value="auto">Despeje automático</option>
                        <option value="izquierda">Despejar x a la izquierda</option>
                        <option value="derecha">Despejar x a la derecha</option>
                        <option value="custom">Función personalizada g(x)</option>
                    </select>
                </div>

                <div class="form-group" id="customGContainer" style="display: none;">
                    <label for="functionG">Función g(x) (personalizada):</label>
                    <input type="text" id="functionG" placeholder="Ejemplo: Math.exp(-x)">
                    <div class="input-help">Función de iteración personalizada</div>
                </div>

                <div id="despejeInfo" class="result-card">
                    <h4>ℹ️ Información de despeje</h4>
                    <p id="despejeTexto">Seleccione el tipo de despeje para generar g(x)</p>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="initialValue">Valor inicial (x₀):</label>
                        <input type="number" id="initialValue" step="any" value="0.5">
                    </div>
                    
                    <div class="form-group">
                        <label for="tolerance">Error deseado (%):</label>
                        <input type="number" id="tolerance" step="0.0001" value="0.5" min="0">
                    </div>
                    
                    <div class="form-group">
                        <label for="maxIterations">Número máximo de iteraciones:</label>
                        <input type="number" id="maxIterations" min="1" value="10">
                    </div>
                </div>

                <button class="btn btn-primary btn-block" onclick="calcular()">Calcular Raíz</button>
            </div>

            <div id="resultado" class="results-section" style="display: none;">
                <h2 class="section-title">Resultados</h2>
                <div id="resultado-contenido"></div>
            </div>
        </div>
    </div>

    <script src="../assets/js/common.js"></script>
    <script>
        // Función para despejar x automáticamente
        function despejarFuncion(funcionF, tipo) {
            // Simplificar la función (eliminar espacios y convertir a minúsculas para análisis)
            let f = funcionF.replace(/\s+/g, '').toLowerCase();
            
            // Intentar diferentes estrategias de despeje
            if (tipo === 'auto' || tipo === 'izquierda') {
                // Estrategia 1: Buscar patrones comunes donde x está a la izquierda
                if (f.includes('x=') || f.includes('x=')) {
                    return f.split('=')[1].trim();
                }
                
                // Estrategia 2: Si la función es de la forma f(x) = x - g(x)
                if (f.includes('x-') || f.includes('x-')) {
                    const partes = f.split('-');
                    if (partes[0] === 'x') {
                        return partes[1];
                    }
                }
                
                // Estrategia 3: Si la función es de la forma f(x) = g(x) - x
                if (f.includes('-x')) {
                    const partes = f.split('-x');
                    if (partes.length === 2) {
                        return partes[0];
                    }
                }
                
                // Estrategia 4: Intentar aislar x algebraicamente para funciones simples
                if (f.includes('x+')) {
                    const partes = f.split('+');
                    if (partes[0] === 'x') {
                        return `(${f.replace('x+', '')}) * -1`;
                    }
                }
            }
            
            if (tipo === 'auto' || tipo === 'derecha') {
                // Estrategia 5: Para ecuaciones cuadráticas simples x² = a
                if (f.includes('x^2') || f.includes('x**2')) {
                    return `sqrt(${f.replace('x^2', '').replace('x**2', '')})`;
                }
                
                // Estrategia 6: Para funciones exponenciales
                if (f.includes('exp(x)') || f.includes('math.exp(x)')) {
                    return `log(${f.replace('exp(x)', '').replace('math.exp(x)', '')})`;
                }
                
                // Estrategia 7: Para funciones logarítmicas
                if (f.includes('log(x)') || f.includes('math.log(x)')) {
                    return `exp(${f.replace('log(x)', '').replace('math.log(x)', '')})`;
                }
            }
            
            // Si no se puede despejar automáticamente, sugerir una forma común
            return "No se pudo despejar automáticamente. Use una función personalizada.";
        }

        function actualizarDespeje() {
            const tipoDespeje = document.getElementById("despejeTipo").value;
            const funcionF = document.getElementById("functionF").value.trim();
            const customGContainer = document.getElementById("customGContainer");
            const despejeTexto = document.getElementById("despejeTexto");
            
            if (tipoDespeje === "custom") {
                customGContainer.style.display = "block";
                despejeTexto.innerHTML = "Ingrese manualmente la función g(x) despejada.";
            } else {
                customGContainer.style.display = "none";
                
                if (funcionF) {
                    try {
                        const gx = despejarFuncion(funcionF, tipoDespeje);
                        despejeTexto.innerHTML = `<strong>Función g(x) generada:</strong> ${gx}<br>
                        <small>Nota: Verifique que esta función es correcta para su problema.</small>`;
                    } catch (e) {
                        despejeTexto.innerHTML = "Error al intentar despejar la función. Use despeje personalizado.";
                    }
                } else {
                    despejeTexto.innerHTML = "Ingrese una función f(x) primero para generar g(x).";
                }
            }
        }

        function obtenerFuncionG() {
            const tipoDespeje = document.getElementById("despejeTipo").value;
            
            if (tipoDespeje === "custom") {
                return document.getElementById("functionG").value.trim();
            } else {
                const funcionF = document.getElementById("functionF").value.trim();
                return despejarFuncion(funcionF, tipoDespeje);
            }
        }

        function puntoFijo(funcionF, funcionG, x0, tolerancia, maxIteraciones) {
            let resultados = [];
            let x = x0;
            let error = 999;
            
            for (let i = 0; i < maxIteraciones; i++) {
                const xNuevo = MathUtils.evaluateFunction(funcionG, x);
                
                if (i > 0) {
                    error = MathUtils.calculateError(xNuevo, x);
                }
                
                const fx = MathUtils.evaluateFunction(funcionF, xNuevo);
                
                resultados.push({
                    iteracion: i + 1,
                    x: x,
                    xNuevo: xNuevo,
                    fx: fx,
                    error: i === 0 ? 999 : error
                });
                
                if (error < tolerancia && i > 0) {
                    return { resultados, raiz: xNuevo };
                }
                
                x = xNuevo;
            }
            
            return { resultados, raiz: x };
        }

        function calcular() {
            const funcionF = document.getElementById("functionF").value.trim();
            let funcionG;
            
            try {
                funcionG = obtenerFuncionG();
            } catch (e) {
                UI.showAlert("Error al obtener la función g(x): " + e.message, "error");
                return;
            }
            
            const x0 = parseFloat(document.getElementById("initialValue").value);
            const tolerancia = parseFloat(document.getElementById("tolerance").value);
            const maxIteraciones = parseInt(document.getElementById("maxIterations").value);

            // Validaciones
            if (!funcionF) {
                UI.showAlert("Por favor, ingrese una función f(x).", "error");
                return;
            }

            if (!funcionG || funcionG.includes("No se pudo despejar")) {
                UI.showAlert("Por favor, ingrese una función g(x) válida o use despeje personalizado.", "error");
                return;
            }

            if (isNaN(x0)) {
                UI.showAlert("Por favor, ingrese un valor inicial válido.", "error");
                return;
            }

            if (isNaN(tolerancia) || tolerancia <= 0) {
                UI.showAlert("El error deseado debe ser un número positivo.", "error");
                return;
            }

            if (isNaN(maxIteraciones) || maxIteraciones <= 0) {
                UI.showAlert("El número de iteraciones debe ser un entero positivo.", "error");
                return;
            }

            try {
                // Validar funciones
                if (!Validators.isValidFunction(funcionF) || !Validators.isValidFunction(funcionG)) {
                    UI.showAlert("Una o ambas funciones no son válidas. Revise la sintaxis.", "error");
                    return;
                }

                const { resultados, raiz } = puntoFijo(funcionF, funcionG, x0, tolerancia, maxIteraciones);

                let html = `<div class="result-summary">
                    <h3>📊 Resumen del Cálculo</h3>
                    <p><strong>Función f(x):</strong> ${funcionF}</p>
                    <p><strong>Función g(x):</strong> ${funcionG}</p>
                    <p><strong>Valor inicial:</strong> x₀ = ${x0}</p>
                    <p><strong>Raíz aproximada:</strong> x = ${MathUtils.formatNumber(raiz)}</p>
                    <p><strong>Verificación:</strong> f(${MathUtils.formatNumber(raiz)}) = ${MathUtils.formatNumber(MathUtils.evaluateFunction(funcionF, raiz))}</p>
                    <p><strong>Iteraciones realizadas:</strong> ${resultados.length}</p>
                </div>`;

                // Generar tabla manualmente
                html += `<div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Iteración</th>
                                <th>xᵢ</th>
                                <th>xᵢ₊₁ = g(xᵢ)</th>
                                <th>f(xᵢ₊₁)</th>
                                <th>Error (%)</th>
                            </tr>
                        </thead>
                        <tbody>`;

                resultados.forEach(r => {
                    html += `<tr>
                        <td>${r.iteracion}</td>
                        <td>${MathUtils.formatNumber(r.x)}</td>
                        <td>${MathUtils.formatNumber(r.xNuevo)}</td>
                        <td>${MathUtils.formatNumber(r.fx)}</td>
                        <td>${r.error === 999 ? '-' : MathUtils.formatNumber(r.error)}</td>
                    </tr>`;
                });

                html += `</tbody></table></div>`;

                document.getElementById("resultado-contenido").innerHTML = html;
                document.getElementById("resultado").style.display = "block";
                
                UI.showAlert("Cálculo completado exitosamente.", "success");

            } catch (e) {
                UI.showAlert(e.message, "error");
                UI.hideResults("resultado");
            }
        }

        // Configuración de validación en tiempo real
        document.addEventListener('DOMContentLoaded', function() {
            FormValidation.setupFunctionValidation('functionF');
            FormValidation.setupFunctionValidation('functionG');
            FormValidation.setupNumericValidation('initialValue', { required: true });
            FormValidation.setupNumericValidation('tolerance', { min: 0, positive: true, required: true });
            FormValidation.setupNumericValidation('maxIterations', { min: 1, required: true });
            
            // Actualizar despeje cuando cambia la función f(x)
            document.getElementById('functionF').addEventListener('input', actualizarDespeje);
        });
    </script>
</body>
</html>