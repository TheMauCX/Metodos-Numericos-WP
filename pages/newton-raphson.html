<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©todo Newton-Raphson - M√©todos Num√©ricos</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body>
    <a href="../index.html" class="back-button">‚Üê Volver al Inicio</a>
    
    <div class="container">
        <div class="page-container">
            <h1 class="page-title">M√©todo Newton-Raphson</h1>
            <p class="subtitle">M√©todo de convergencia r√°pida utilizando la derivada de la funci√≥n</p>

            <div class="form-section">
                <h2 class="section-title">Par√°metros de Entrada</h2>
                
                <div class="form-group">
                    <label for="function">Funci√≥n f(x):</label>
                    <input type="text" id="function" value="x^2 - 5" placeholder="Ejemplo: x^2 - 4">
                    <div class="input-help">Use notaci√≥n est√°ndar: x^2, sin(x), cos(x), tan(x), log(x), exp(x), sqrt(x)</div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="initialValue">Valor inicial (x‚ÇÄ):</label>
                        <input type="number" id="initialValue" step="any" value="5" placeholder="Punto de partida">
                    </div>
                    <div class="form-group">
                        <label for="tolerance">Error deseado (%):</label>
                        <input type="number" id="tolerance" step="any" value="0.01" min="0" placeholder="Tolerancia">
                    </div>
                </div>

                <div class="form-group">
                    <label for="maxIterations">N√∫mero m√°ximo de iteraciones:</label>
                    <input type="number" id="maxIterations" value="10" min="1" placeholder="L√≠mite de iteraciones">
                </div>

                <button class="btn btn-primary btn-block" onclick="calculate()">Calcular Ra√≠z</button>
            </div>

            <div id="resultado" class="results-section" style="display: none;">
                <h2 class="section-title">Resultados</h2>
                <div id="resultado-contenido"></div>
            </div>
        </div>
    </div>

    <script src="../assets/js/common.js"></script>
    <script>
        function parseFunction(expr) {
            // Preparar expresi√≥n para evaluaci√≥n
            let processedExpr = expr
                .replace(/sin\(/g, 'Math.sin(')
                .replace(/cos\(/g, 'Math.cos(')
                .replace(/tan\(/g, 'Math.tan(')
                .replace(/log\(/g, 'Math.log10(')
                .replace(/ln\(/g, 'Math.log(')
                .replace(/exp\(/g, 'Math.exp(')
                .replace(/sqrt\(/g, 'Math.sqrt(')
                .replace(/\^/g, '**');
            
            return function(x) {
                try {
                    let evaluatedExpr = processedExpr.replace(/\bx\b/g, `(${x})`);
                    return eval(evaluatedExpr);
                } catch (error) {
                    throw new Error("Error al evaluar la funci√≥n: " + error.message);
                }
            };
        }

        function newtonRaphson(functionExpr, initialValue, tolerance, maxIterations) {
            const f = parseFunction(functionExpr);
            
            // Verificar que la funci√≥n sea v√°lida con el valor inicial
            const testValue = f(initialValue);
            if (!isFinite(testValue)) {
                throw new Error("La funci√≥n produce un valor no v√°lido en el punto inicial.");
            }
            
            let x = initialValue;
            let iterations = [];
            let error = 100;
            
            for (let i = 0; i < maxIterations; i++) {
                const f_x = f(x);
                const f_prime_x = MathUtils.derivative(f, x);
                
                // Verificar divisi√≥n por cero
                if (Math.abs(f_prime_x) < 1e-10) {
                    throw new Error(`La derivada es casi cero en x = ${x.toFixed(6)}. El m√©todo no puede continuar.`);
                }
                
                const x_new = x - f_x / f_prime_x;
                
                // Verificar que el nuevo valor sea v√°lido
                if (!isFinite(x_new)) {
                    throw new Error("El m√©todo produjo un valor no v√°lido. Intente con otro valor inicial.");
                }
                
                // Calcular error aproximado
                if (i > 0) {
                    error = MathUtils.calculateError(x_new, x);
                }
                
                iterations.push({
                    iteration: i + 1,
                    x: x,
                    f_x: f_x,
                    f_prime_x: f_prime_x,
                    x_new: x_new,
                    error: i > 0 ? error : null
                });
                
                // Verificar convergencia
                if (error < tolerance && i > 0) {
                    break;
                }
                
                x = x_new;
            }
            
            return { iterations, finalRoot: x, converged: error < tolerance };
        }

        function calculate() {
            const functionExpr = document.getElementById('function').value.trim();
            const initialValue = parseFloat(document.getElementById('initialValue').value);
            const tolerance = parseFloat(document.getElementById('tolerance').value);
            const maxIterations = parseInt(document.getElementById('maxIterations').value);
            
            // Validaciones
            if (!functionExpr) {
                UI.showAlert("Por favor, ingrese una funci√≥n v√°lida.", "error");
                return;
            }
            
            if (isNaN(initialValue)) {
                UI.showAlert("Por favor, ingrese un valor inicial v√°lido.", "error");
                return;
            }
            
            if (isNaN(tolerance) || tolerance <= 0) {
                UI.showAlert("Por favor, ingrese un error deseado v√°lido (mayor que 0).", "error");
                return;
            }
            
            if (isNaN(maxIterations) || maxIterations <= 0) {
                UI.showAlert("Por favor, ingrese un n√∫mero m√°ximo de iteraciones v√°lido.", "error");
                return;
            }
            
            try {
                const { iterations, finalRoot, converged } = newtonRaphson(functionExpr, initialValue, tolerance, maxIterations);
                
                const lastIteration = iterations[iterations.length - 1];
                const f = parseFunction(functionExpr);
                
                let html = `<div class="result-summary">
                    <h3>üìä Resumen del C√°lculo</h3>
                    <p><strong>Funci√≥n:</strong> f(x) = ${functionExpr}</p>
                    <p><strong>M√©todo:</strong> Newton-Raphson</p>
                    <p><strong>Valor inicial:</strong> x‚ÇÄ = ${MathUtils.formatNumber(initialValue, 6)}</p>
                    <p><strong>Ra√≠z aproximada:</strong> x = ${MathUtils.formatNumber(finalRoot)}</p>
                    <p><strong>Verificaci√≥n:</strong> f(${MathUtils.formatNumber(finalRoot)}) = ${MathUtils.formatNumber(f(finalRoot))}</p>
                    <p><strong>Estado:</strong> ${converged ? '‚úÖ Convergencia alcanzada' : '‚ö†Ô∏è M√°ximo de iteraciones alcanzado'}</p>
                    <p><strong>Iteraciones realizadas:</strong> ${iterations.length}</p>
                </div>`;

                const headers = ['Iteraci√≥n', 'x·µ¢', 'f(x·µ¢)', 'f\'(x·µ¢)', 'x·µ¢‚Çä‚ÇÅ', 'Error (%)'];
                const tableData = iterations.map(iter => ({
                    iteration: iter.iteration,
                    x: iter.x,
                    f_x: iter.f_x,
                    f_prime_x: iter.f_prime_x,
                    x_new: iter.x_new,
                    error: iter.error === null ? '-' : iter.error
                }));

                html += TableGenerator.create(headers, tableData, {
                    cellFormatter: (value) => {
                        if (value === '-') return value;
                        return typeof value === 'number' ? MathUtils.formatNumber(value) : value;
                    }
                });

                if (converged) {
                    UI.showAlert(`¬°Convergencia alcanzada! La ra√≠z aproximada es ${MathUtils.formatNumber(finalRoot)} con un error del ${MathUtils.formatNumber(lastIteration.error || 0, 6)}%`, "success");
                } else {
                    UI.showAlert("Se alcanz√≥ el m√°ximo de iteraciones sin convergencia. Intente con otro valor inicial o aumente las iteraciones.", "warning");
                }

                UI.showResults("resultado-contenido", html);
                
            } catch (e) {
                UI.showAlert(e.message, "error");
                UI.hideResults("resultado");
            }
        }
    </script>
</body>
</html>